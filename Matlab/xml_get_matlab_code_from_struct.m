function [cell_array_of_code] = xml_get_matlab_code_from_struct(xml_struct)
%XML_GET_MATLAB_CODE_FROM_STRUCT [cell_array_of_code] = get_matlab_code_from_xml_struct(xml_struct)
%   This function reads in a structure created from an XML file or string,
%   and returns all the detected variables as strings to be executed in the
%   main code.
% IMPORTANT:
%   Make sure your XML string correctly defines the data types. Don't change
%   the order of data, and the order of parameters. Also, and don't omit
%   parameters. If you don't want a comment on, then just put a blank space in it.
%
% Detectectable data types are, with examples as xml children:
% -Matrices:
%       <matrix description="Some matrix I wanted to save." ncols="4" nrows="4" variable_name="the_matrix">
%           <row_0>
%               <col_0>0</col_0>
%               <col_1>0</col_1>
%               <col_2>0</col_2>
%               <col_3>0</col_3>
%           </row_0>
%           <row_1>
%               <col_0>1</col_0>
%               <col_1>2</col_1>
%               <col_2>4</col_2>
%               <col_3>5</col_3>
%           </row_1>
%           <row_2>
%               <col_0>12</col_0>
%               <col_1>12</col_1>
%               <col_2>43</col_2>
%               <col_3>43</col_3>
%           </row_2>
%           <row_3>
%               <col_0>8</col_0>
%               <col_1>8</col_1>
%               <col_2>8</col_2>
%               <col_3>8</col_3>
%           </row_3>
%       </matrix>
%
% -Strings:
%       <string description="Message" variable_name="string">Woohoo.</string>
% -Booleans:
%       <boolean description="Button Status" variable_name="button_status">True</boolean>

    % Do some sanity checks first.
    if(~isstruct(xml_struct))
        error('Input variable must be a structure, generated by Matlab, from an XML file or string.')
    end

    found_variable_pointer = 1; % The xml file can contain an arbitrary number of data.
    
    for(i = 1:length(xml_struct.Children))
    % Let's scan through everything, and shove it into a switch_case
    % statement
    variable_type = xml_struct.Children(i).Name;
    
    switch variable_type        
        case 'matrix'
            %fprintf('Slot %d is a matrix.\n', i) %debug.
            % This is the most complicated one. We need to get the
            % dimensions of the matrix, and then populate it
            % algorithmically.
            matrix_string_preamble = sprintf("%s = [", xml_struct.Children(i).Attributes(3).Value);
            matrix_string_end = sprintf("];");
            no_of_rows = str2num(xml_struct.Children(i).Attributes(2).Value);
            no_of_columns = str2num(xml_struct.Children(i).Attributes(1).Value);
            matrix_string_pulp = ''; % initialise the pulp
            % ...and now we have to do the nested loops for rows and
            % columns.
            for(j = 1:no_of_rows)
                for(k = 1:no_of_columns)
                    % So let's see...
                    matrix_string_pulp = [matrix_string_pulp, xml_struct.Children(i).Children(j*2).Children(k*2).Children.Data]; %We step in twos.
                    if(k < no_of_columns)
                        matrix_string_pulp = [matrix_string_pulp, ', ']; %Add the inter-column separator, except for the last one.
                    end
                    
                end
                matrix_string_pulp = [matrix_string_pulp, '; ']; % Add the line terminator.
            end
            
            % ...and that's it! We just merge the three strings, as a
            % sandiwch: preamble - pulp - end
            matrix_string = strcat(matrix_string_preamble, matrix_string_pulp, matrix_string_end);
            
            % Execute.
            
            cell_array_of_code{found_variable_pointer} = matrix_string;
            found_variable_pointer = found_variable_pointer + 1; % Increase the pointer.
            
            
        case 'string'
            %fprintf('Slot %d is a string.\n', i) %debug
            string_string = sprintf('%s = ''%s'';', ...
                xml_struct.Children(i).Attributes(1).Value, ...
                xml_struct.Children(i).Children.Data);
            % This is easy.
            cell_array_of_code{found_variable_pointer} = string_string;
            found_variable_pointer = found_variable_pointer + 1; % Increase the pointer.
            
        case 'boolean'
            %fprintf('Slot %d is a boolean.\n', i) %debug.
            % This one is a bit more complicated. We need to check for the
            % value, because it could be anything.
            value_from_xml_string = xml_struct.Children(i).Children.Data;
            if(strcmp(value_from_xml_string, 'True') || strcmp(value_from_xml_string, 'true') || strcmp(value_from_xml_string, '1'))
                % Boolean value is true.
                boolean_string = sprintf('%s = true;', ...
                    xml_struct.Children(i).Attributes(1).Value);
            else
                % Boolean value is false.
                boolean_string = sprintf('%s = false;', ...
                    xml_struct.Children(i).Attributes(1).Value);
            end
            % Add this.
            cell_array_of_code{found_variable_pointer} = boolean_string;
            found_variable_pointer = found_variable_pointer + 1; % Increase the pointer.
        
        otherwise
            % If we got here, we didn't find anything. Don't do anything
            % about it.
        end
    
    end
    
    

end

